#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
// clang-format off
#include "ray_payload.glsl"
#include "uniform_objects.glsl"
#include "material.glsl"
#include "constants.glsl"
// #include "vertex.glsl"
// clang-format on

layout(binding = 0) uniform accelerationStructureEXT scene;
layout(binding = 1, rgba32f) uniform image2D accumulation_color;
layout(binding = 2, r32f) uniform image2D accumulation_number;
layout(binding = 3) uniform global_uniform_object {
  GlobalUniformObject guo;
};
layout(binding = 4) readonly buffer entity_array {
  EntityUniformObject entity_objects[];
};
layout(binding = 5) readonly buffer material_array {
  Material materials[];
};
layout(binding = 6) readonly buffer object_info_array {
  ObjectInfo object_infos[];
};
layout(binding = 7) readonly buffer vertex_array {
  float vertices[];
};
layout(binding = 8) readonly buffer index_array {
  uint indices[];
};
layout(binding = 9) uniform sampler2D[] texture_samplers;
layout(binding = 10) readonly buffer emission_array {
  uint emissions[];
};

layout(location = 0) rayPayloadEXT RayPayload ray_payload;

// clang-format off
#include "vertex.glsl"
#include "hit_record.glsl"
#include "random.glsl"
// clang-format on

vec3 SampleEnvmap(vec3 direction) {
  float x = guo.envmap_offset;
  float y = acos(direction.y) * INV_PI;
  if (length(vec2(direction.x, direction.y)) > 1e-4) {
    x += atan(direction.x, -direction.z);
  }
  x *= INV_PI * 0.5;
  return texture(texture_samplers[guo.envmap_id], vec2(x, y))
      .xyz;  // textures_[envmap_id_].Sample(glm::);
}

HitRecord hit_record;
bool TraceRay(vec3 origin, vec3 direction, float tmax) {
  float tmin = 1e-3;
  // float tmax = 1e4;

  ray_payload.t = -1.0;
  ray_payload.barycentric = vec3(0.0);
  ray_payload.object_id = 0;
  ray_payload.primitive_id = 0;
  ray_payload.object_to_world = mat4x3(1.0);

  traceRayEXT(scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin,
              direction, tmax, 0);
  if (ray_payload.t == -1.0) {
    return false;
  }
  else {
    hit_record = GetHitRecord(ray_payload, origin, direction);
    return true;
  }
}

vec3 SampleRay(vec3 origin, vec3 direction) {
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);
  for (int b = 0; b < guo.num_bounces; b++) {
    if (!TraceRay(origin, direction, 1e4)) {
      radiance += throughput * SampleEnvmap(direction);
      break;
    } else {
      Material material = materials[hit_record.hit_entity_id];
      throughput *= material.diffuse *
                    vec3(texture(texture_samplers[material.diffuse_texture_id],
                                 hit_record.tex_coord));
      origin = hit_record.position;
      direction = guo.envmap_light_direction;
      radiance += throughput * guo.envmap_minor_color;
      throughput *= max(dot(direction, hit_record.normal), 0.0) * 2.0;
      if (!TraceRay(origin, direction, 1e4)) {
        radiance += throughput * guo.envmap_major_color;
      }
      break;
    }
  }
  return radiance;
}

vec3 BRDFImportanceSampling(vec3 N, vec3 T, Material material) {
  float phi = 2.0 * PI * RandomFloat();
  float theta;
  if (material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
    // theta = asin(sqrt(RandomFloat()));
    theta = acos(1.0 - 2.0 * RandomFloat()) * 0.5;
  }
  else if (material.material_type == MATERIAL_TYPE_SPECULAR) {
    theta = acos(pow(RandomFloat(), 1 / (material.shininess + 1)));
  }
  vec3 B = cross(N, T);
  vec3 W = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
  vec3 wi = T * W.x + B * W.y + N * W.z;
  return wi;
}

// vec3 SampleLight(vec3 origin, vec3 normal) {
//   vec3 energy = vec3(0.0);
//   uint light_id = RandomInt(guo.num_lights);
//   Light light = lights[light_id];
//   if (light.light_type == LIGHT_TYPE_POINT) {

//   }
//   else if (light.light_type == LIGHT_TYPE_SPHERE) {

//   }
//   else if (light.light_type == LIGHT_TYPE_RECTANGLE) {

//   }
//   else if (light.light_type == LIGHT_TYPE_TRIANGLE) {
//     float su = RandomFloat();
//     float sv = RandomFloat();
//     vec3 light_origin = light.p0 + su * light.p1 + sv * light.p2;
//     vec3 sign_area = cross(light.p1, light.p2);
//     float area = sqrt(dot(sign_area, sign_area));
//     vec3 light_normal = sign_area / area;
//     vec3 wi = normalize(light_origin - origin);
//     float dist = distance(origin, light_origin); 
//     TraceRay(origin, wi, dist);
//     if (ray_payload.t < 0.0) {
//       float cos_i = max(dot(normal, wi), 0.0);
//       float cos_o = max(dot(light_normal, -wi), 0.0);
//       energy = light.emission * cos_i * cos_o * area / (dist * dist);
//     }
//   }
//   return energy;
// }

void SampleSolidAngle(vec3 origin, mat3 positions, out float area, out vec3 wi) {
  vec3 A = normalize(positions[0] - origin);
  vec3 B = normalize(positions[1] - origin);
  vec3 C = normalize(positions[2] - origin);
  float cosa = dot(B, C);
  float sina = sqrt(1.0 - cosa * cosa);
  float cosb = dot(C, A);
  float sinb = sqrt(1.0 - cosb * cosb);
  float cosc = dot(A, B);
  float sinc = sqrt(1.0 - cosc * cosc);
  float cosA = (cosa - cosb * cosc) / (sinb * sinc);
  float cosB = (cosb - cosc * cosa) / (sinc * sina);
  float cosC = (cosc - cosa * cosb) / (sina * sinb);
  float alpha = acos(cosA);
  float sinA = sin(alpha);
  float beta = acos(cosB);
  float gamma = acos(cosC);
  area = max(alpha + beta + gamma - PI, 0.0);

  float area_h = RandomFloat() * area;
  float s = sin(area_h - alpha);
  float t = cos(area_h - alpha);
  float u = t - cosA;
  float v = s + sinA * cosc;
  float q = ((v * t - u * s) * cosA - v) / ((v * s + u * t) * sinA);
  vec3 CIA = normalize(C - dot(C, A) * A);
  vec3 C_h = q * A + sqrt(1.0 - q * q) * CIA;
  float z = 1.0 - RandomFloat() * (1.0 - dot(C_h, B));
  vec3 C_hIB = normalize(C_h - dot(C_h, B) * B);
  wi = z * B + sqrt(1 - z * z) * C_hIB;

  // float alpha = RandomFloat() * acos(cosa);
  // vec3 B_I_C = normalize(C - dot(C, B) * B);
  // vec3 B_new = cos(alpha) * B + sin(alpha) * B_I_C;
  // float cos_theta = dot(A, B_new);
  // float cos_beta = 1.0 - (1.0 - cos_theta) * RandomFloat();
  // vec3 A_I_B_new = normalize(B_new - dot(B_new, A) * A);
  // wi = cos_beta * A + sqrt(1.0 - cos_beta * cos_beta) * A_I_B_new;
}

vec3 SampleEmission(vec3 origin, vec3 origin_normal) {
  vec3 energy = vec3(0.0);
  uint emission_id = RandomInt(guo.num_emissions);
  // for (uint emission_id = 0; emission_id < guo.num_emissions; emission_id++) {
  uint emission_entity_id = emissions[emission_id];
  ObjectInfo object_info = object_infos[emission_entity_id];
  uint face_id = RandomInt(object_info.num_faces);
  // for (uint face_id = 0; face_id < object_info.num_faces; face_id++) {
  Vertex v0 = GetVertex(
      object_info.vertex_offset +
      indices[object_info.index_offset + face_id * 3 + 0]);
  Vertex v1 = GetVertex(
      object_info.vertex_offset +
      indices[object_info.index_offset + face_id * 3 + 1]);
  Vertex v2 = GetVertex(
      object_info.vertex_offset +
      indices[object_info.index_offset + face_id * 3 + 2]);
  // vec3 barycentric;
  // barycentric.x = RandomFloat();
  // barycentric.y = RandomFloat() * (1.0 - barycentric.x);
  // barycentric.z = 1 - barycentric.x - barycentric.y;
  mat3 object_to_world = mat3(entity_objects[emission_entity_id].model);
  mat3 positions = mat3(entity_objects[emission_entity_id].model * 
                        mat3x4(vec4(v0.position, 1.0), vec4(v1.position, 1.0), 
                               vec4(v2.position, 1.0)));

  // if (length(positions[0] - vec3(0.343, 0.548, 0.227)) < 1e-3) {
  //   return vec3(0.0, 1.0, 1.0);
  // }
  // else {
  //   return vec3(1.0, 0.0, 1.0);
  // }
  float angle;
  vec3 wi;
  // bool result = 
  SampleSolidAngle(origin, positions, angle, wi);
  // if (result) {
  //   return vec3(1.0);
  // }
  // else {
  //   return vec3(0.0);
  // }
  // vec3 position = positions * barycentric;
  // float ray_length = length(position - origin);
  // vec3 direction = normalize(position - origin);
  // vec3 normal = normalize(transpose(inverse(object_to_world)) *
  //                         mat3(v0.normal, v1.normal, v2.normal) *
  //                         barycentric);
  // vec3 sign_area = 
  //      transpose(inverse(object_to_world)) *
  //                cross(v1.position - v0.position, v2.position - v0.position);
  // float area = length(sign_area) / 2.0 ;
  // vec3 geometry_normal = normalize(sign_area);
  // if (dot(normal, geometry_normal) < 0.0) {
  //   geometry_normal = -geometry_normal;
  // }
  // if (dot(direction, geometry_normal) > 0.0) {
  //   geometry_normal = -geometry_normal;
  //   normal = -normal;
  // }
  // if (dot(-direction, normal) > 0) {
  //   return vec3(0.0, 0.0, 1.0);
  // }
  // else {
  //   return vec3(0.0);
  // }
  // if (angle < 0) {
  //   return vec3(1.0,1.0,1.0);
  // }
  // else {
  //   return vec3(0.0);
  // }

  // if (!TraceRay(origin, direction, ray_length - 1e-3)) {
  if (TraceRay(origin, wi, 1e4)) {
    // return vec3(0.0, 0.0, 1.0);
    // return 20.0 * vec3(angle);
    // float cos_i = max(dot(origin_normal, direction), 0.0f);
    // float cos_o = max(dot(normal, -direction), 0.0f);
    // float f0 = cos_i * cos_o / (ray_length * ray_length);
    // float cos_i_o = max(dot(origin_normal, normal), 0.0);
    if (hit_record.hit_entity_id == emission_entity_id && 
        ray_payload.primitive_id == face_id) {
      energy = materials[emission_entity_id].emission *  
               max(dot(origin_normal, wi), 0.0) * angle *
               object_info.num_faces * guo.num_emissions;
    }
    // energy = f0 * area * materials[emission_entity_id].emission * angle;
    // return vec3(0.0, 0.0, 1.0);
    // return cos_i * cos_o * materials[emission_entity_id].emission;
  }
  // energy = clamp(energy, 0.0, 1.0);
  // }}
  return energy;
}

vec3 SampleRay1(vec3 origin, vec3 direction) {
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);
  vec3 p = origin;
  vec3 n = direction;
  vec3 wo = direction;
  vec3 wi = direction;
  vec3 Fr;
  Material material;
  if (!TraceRay(p, wi, 1e4)) {
    radiance += throughput * SampleEnvmap(wi);
    return radiance;
  }
  else {
    material = materials[hit_record.hit_entity_id];
    if (material.material_type == MATERIAL_TYPE_EMISSION) {
      radiance += throughput * material.emission;
    }
  }
  // radiance += INV_PI * SampleLight(p, n);
  // float prob = pow(1e-6, 1.0 / guo.num_bounces);
  float prob = 0.8;
  int cnt = 0;
  for (float b = RandomFloat(); b < prob && cnt < guo.num_bounces; b = RandomFloat()) {
  // float prob = guo.num_bounces / (guo.num_bounces + 1.0);
  // int cnt = 0;
  // for (float b = 0.0; b < prob && cnt < 4 * guo.num_bounces; b = RandomFloat()) {
    // if (material.material_type == MATERIAL_TYPE_EMISSION) {
    //   radiance += throughput * material.emission;
    //   break;
    // }
    // vec3 Li = material.diffuse * 0.5 * INV_PI / dot(n, wi) / dot(r, r);
    p = hit_record.position;
    n = hit_record.normal;
    vec3 t = hit_record.tangent;

    Fr = material.diffuse *
              vec3(texture(texture_samplers[material.diffuse_texture_id],
                    hit_record.tex_coord)) + 
         material.specular * 
              vec3(texture(texture_samplers[material.specular_texture_id],
                    hit_record.tex_coord));


    wo = -wi;
    wi = BRDFImportanceSampling(n, t, material);

    throughput *= Fr / prob;

    radiance += throughput * INV_PI * SampleEmission(p, n);
    // radiance += throughput * SampleEmission(p, n);

    if (!TraceRay(p, wi, 1e4)) {
      vec3 env_ambient = guo.envmap_minor_color + guo.envmap_major_color * 2.0 *
                  max(0.0, dot(guo.envmap_light_direction, hit_record.normal));
      radiance += throughput * env_ambient * material.ambient * 
                  vec3(texture(texture_samplers[material.ambient_texture_id],
                                hit_record.tex_coord));
      break;
    }
    material = materials[hit_record.hit_entity_id];
    // radiance += throughput * material.emission;

    // if ((material.material_type & MATERIAL_TYPE_EMISSION) > 0) {
    //   break;
    // }

    // radiance += throughput * guo.envmap_minor_color;
    // throughput *= max(dot(direction, hit_record.normal), 0.0) * 2.0;
    // if (!TraceRay(origin, direction)) {
    //   radiance += throughput * guo.envmap_major_color;
    // }
    // break;
    cnt++;
  }
  return radiance;
}

void main() {
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;

  mat4 camera_to_world = inverse(guo.camera);
  mat4 screen_to_camera = inverse(guo.projection);

  for (int i = 0; i < guo.num_samples; i++) {
    InitRandomSeed(uint(pixelCenter.x), uint(pixelCenter.y),
                   guo.accumulated_sample + i);
    vec4 origin = camera_to_world * vec4(0, 0, 0, 1);
    vec4 target = screen_to_camera * vec4(d.x, d.y, 1, 1);
    vec4 direction = camera_to_world * vec4(normalize(target.xyz), 0);

    imageStore(accumulation_color, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_color, ivec2(gl_LaunchIDEXT.xy)) +
                   vec4(SampleRay1(origin.xyz, direction.xyz), 1.0));
    imageStore(accumulation_number, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_number, ivec2(gl_LaunchIDEXT.xy)) + 1.0);
  }
}
