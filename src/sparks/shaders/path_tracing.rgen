#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
// clang-format off
#include "ray_payload.glsl"
#include "uniform_objects.glsl"
#include "material.glsl"
#include "constants.glsl"
// #include "vertex.glsl"
// clang-format on

layout(binding = 0) uniform accelerationStructureEXT scene;
layout(binding = 1, rgba32f) uniform image2D accumulation_color;
layout(binding = 2, r32f) uniform image2D accumulation_number;
layout(binding = 3) uniform global_uniform_object {
  GlobalUniformObject guo;
};
layout(binding = 4) readonly buffer entity_array {
  EntityUniformObject entity_objects[];
};
layout(binding = 5) readonly buffer material_array {
  Material materials[];
};
layout(binding = 6) readonly buffer object_info_array {
  ObjectInfo object_infos[];
};
layout(binding = 7) readonly buffer vertex_array {
  float vertices[];
};
layout(binding = 8) readonly buffer index_array {
  uint indices[];
};
layout(binding = 9) uniform sampler2D[] texture_samplers;
layout(binding = 10) readonly buffer emission_array {
  uint emissions[];
};

layout(location = 0) rayPayloadEXT RayPayload ray_payload;

// clang-format off
#include "vertex.glsl"
#include "hit_record.glsl"
#include "random.glsl"
// clang-format on

vec3 SampleEnvmap(vec3 direction) {
  float x = guo.envmap_offset;
  float y = acos(direction.y) * INV_PI;
  if (length(vec2(direction.x, direction.y)) > 1e-4) {
    x += atan(direction.x, -direction.z);
  }
  x *= INV_PI * 0.5;
  return texture(texture_samplers[guo.envmap_id], vec2(x, y))
      .xyz;  // textures_[envmap_id_].Sample(glm::);
}

HitRecord hit_record;
bool TraceRay(vec3 origin, vec3 direction) {
  float tmin = 1e-3;
  float tmax = 1e5;

  ray_payload.t = -1.0;
  ray_payload.barycentric = vec3(0.0);
  ray_payload.object_id = 0;
  ray_payload.primitive_id = 0;
  ray_payload.object_to_world = mat4x3(1.0);

  traceRayEXT(scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin,
              direction, tmax, 0);
  if (ray_payload.t == -1.0) {
    return false;
  }
  else {
    hit_record = GetHitRecord(ray_payload, origin, direction);
    return true;
  }
}

vec3 SampleRay(vec3 origin, vec3 direction) {
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);
  for (int b = 0; b < guo.num_bounces; b++) {
    if (!TraceRay(origin, direction)) {
      radiance += throughput * SampleEnvmap(direction);
      break;
    } else {
      Material material = materials[hit_record.hit_entity_id];
      if (material.material_type == MATERIAL_TYPE_EMISSION) {
        radiance += throughput * material.emission * material.emission_strength;
        break;
      } else {
        throughput *= material.diffuse *
                      vec3(texture(texture_samplers[material.diffuse_texture_id],
                                  hit_record.tex_coord));
        origin = hit_record.position;
        direction = guo.envmap_light_direction;
        radiance += throughput * guo.envmap_minor_color;
        throughput *= max(dot(direction, hit_record.normal), 0.0) * 2.0;
        if (!TraceRay(origin, direction)) {
          radiance += throughput * guo.envmap_major_color;
        }
        break;
      }
    }
  }
  return radiance;
}

vec3 ImportanceSamplingLamberrian(vec3 N, vec3 T) {
  float phi = 2.0 * PI * RandomFloat();
  float theta = acos(1.0 - 2.0 * RandomFloat()) * 0.5;
  vec3 B = cross(N, T);
  vec3 W = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
  vec3 wi = T * W.x + B * W.y + N * W.z;
  return wi;
}

vec3 ImportanceSamplingSpecular(in vec3 N, in vec3 T, in float roughness) {
  float phi = 2.0 * PI * RandomFloat();
  // float theta = acos(1.0 - 2.0 * RandomFloat()) * 0.5;
  float ksi = RandomFloat();  
  float cos_theta = sqrt((1.0 - ksi) / (ksi * (roughness * roughness - 1.0) + 1.0));
  float sin_theta = sqrt(1.0 - cos_theta * cos_theta);
  // float theta = acos();
  vec3 B = cross(N, T);
  vec3 W = vec3(sin_theta * cos(phi), sin_theta * sin(phi), cos_theta);
  return T * W.x + B * W.y + N * W.z;
}

// vec3 SampleLight(vec3 origin, vec3 normal) {
//   vec3 energy = vec3(0.0);
//   uint light_id = RandomInt(guo.num_lights);
//   Light light = lights[light_id];
//   if (light.light_type == LIGHT_TYPE_POINT) {

//   }
//   else if (light.light_type == LIGHT_TYPE_SPHERE) {

//   }
//   else if (light.light_type == LIGHT_TYPE_RECTANGLE) {

//   }
//   else if (light.light_type == LIGHT_TYPE_TRIANGLE) {
//     float su = RandomFloat();
//     float sv = RandomFloat();
//     vec3 light_origin = light.p0 + su * light.p1 + sv * light.p2;
//     vec3 sign_area = cross(light.p1, light.p2);
//     float area = sqrt(dot(sign_area, sign_area));
//     vec3 light_normal = sign_area / area;
//     vec3 wi = normalize(light_origin - origin);
//     float dist = distance(origin, light_origin); 
//     TraceRay(origin, wi, dist);
//     if (ray_payload.t < 0.0) {
//       float cos_i = max(dot(normal, wi), 0.0);
//       float cos_o = max(dot(light_normal, -wi), 0.0);
//       energy = light.emission * cos_i * cos_o * area / (dist * dist);
//     }
//   }
//   return energy;
// }

void SampleSolidAngle(vec3 origin, mat3 positions, out float area, out vec3 wi) {
  vec3 A = normalize(positions[0] - origin);
  vec3 B = normalize(positions[1] - origin);
  vec3 C = normalize(positions[2] - origin);
  float cosa = dot(B, C);
  float sina = sqrt(1.0 - cosa * cosa);
  float cosb = dot(C, A);
  float sinb = sqrt(1.0 - cosb * cosb);
  float cosc = dot(A, B);
  float sinc = sqrt(1.0 - cosc * cosc);
  float cosA = (cosa - cosb * cosc) / (sinb * sinc);
  float cosB = (cosb - cosc * cosa) / (sinc * sina);
  float cosC = (cosc - cosa * cosb) / (sina * sinb);
  float alpha = acos(cosA);
  float sinA = sin(alpha);
  float beta = acos(cosB);
  float gamma = acos(cosC);
  area = max(alpha + beta + gamma - PI, 0.0);

  float area_h = RandomFloat() * area;
  float s = sin(area_h - alpha);
  float t = cos(area_h - alpha);
  float u = t - cosA;
  float v = s + sinA * cosc;
  float q = ((v * t - u * s) * cosA - v) / ((v * s + u * t) * sinA);
  vec3 CIA = normalize(C - dot(C, A) * A);
  vec3 C_h = q * A + sqrt(1.0 - q * q) * CIA;
  float z = 1.0 - RandomFloat() * (1.0 - dot(C_h, B));
  vec3 C_hIB = normalize(C_h - dot(C_h, B) * B);
  wi = z * B + sqrt(1 - z * z) * C_hIB;

  // float alpha = RandomFloat() * acos(cosa);
  // vec3 B_I_C = normalize(C - dot(C, B) * B);
  // vec3 B_new = cos(alpha) * B + sin(alpha) * B_I_C;
  // float cos_theta = dot(A, B_new);
  // float cos_beta = 1.0 - (1.0 - cos_theta) * RandomFloat();
  // vec3 A_I_B_new = normalize(B_new - dot(B_new, A) * A);
  // wi = cos_beta * A + sqrt(1.0 - cos_beta * cos_beta) * A_I_B_new;
}

vec3 SampleEmission(vec3 origin, vec3 origin_normal) {
  vec3 energy = vec3(0.0);
  uint emission_id = RandomInt(guo.num_emissions);
  // for (uint emission_id = 0; emission_id < guo.num_emissions; emission_id++) {
  uint emission_entity_id = emissions[emission_id];
  ObjectInfo object_info = object_infos[emission_entity_id];
  uint face_id = RandomInt(object_info.num_faces);
  // for (uint face_id = 0; face_id < object_info.num_faces; face_id++) {
  Vertex v0 = GetVertex(
      object_info.vertex_offset +
      indices[object_info.index_offset + face_id * 3 + 0]);
  Vertex v1 = GetVertex(
      object_info.vertex_offset +
      indices[object_info.index_offset + face_id * 3 + 1]);
  Vertex v2 = GetVertex(
      object_info.vertex_offset +
      indices[object_info.index_offset + face_id * 3 + 2]);
  // vec3 barycentric;
  // barycentric.x = RandomFloat();
  // barycentric.y = RandomFloat() * (1.0 - barycentric.x);
  // barycentric.z = 1 - barycentric.x - barycentric.y;
  mat3 object_to_world = mat3(entity_objects[emission_entity_id].model);
  mat3 positions = mat3(entity_objects[emission_entity_id].model * 
                        mat3x4(vec4(v0.position, 1.0), vec4(v1.position, 1.0), 
                               vec4(v2.position, 1.0)));

  // if (length(positions[0] - vec3(0.343, 0.548, 0.227)) < 1e-3) {
  //   return vec3(0.0, 1.0, 1.0);
  // }
  // else {
  //   return vec3(1.0, 0.0, 1.0);
  // }
  float angle;
  vec3 wi;
  // bool result = 
  SampleSolidAngle(origin, positions, angle, wi);
  // if (result) {
  //   return vec3(1.0);
  // }
  // else {
  //   return vec3(0.0);
  // }
  // vec3 position = positions * barycentric;
  // float ray_length = length(position - origin);
  // vec3 direction = normalize(position - origin);
  // vec3 normal = normalize(transpose(inverse(object_to_world)) *
  //                         mat3(v0.normal, v1.normal, v2.normal) *
  //                         barycentric);
  // vec3 sign_area = 
  //      transpose(inverse(object_to_world)) *
  //                cross(v1.position - v0.position, v2.position - v0.position);
  // float area = length(sign_area) / 2.0 ;
  // vec3 geometry_normal = normalize(sign_area);
  // if (dot(normal, geometry_normal) < 0.0) {
  //   geometry_normal = -geometry_normal;
  // }
  // if (dot(direction, geometry_normal) > 0.0) {
  //   geometry_normal = -geometry_normal;
  //   normal = -normal;
  // }
  // if (dot(-direction, normal) > 0) {
  //   return vec3(0.0, 0.0, 1.0);
  // }
  // else {
  //   return vec3(0.0);
  // }
  // if (angle < 0) {
  //   return vec3(1.0,1.0,1.0);
  // }
  // else {
  //   return vec3(0.0);
  // }

  // if (!TraceRay(origin, direction, ray_length - 1e-3)) {
  HitRecord save_hit_record = hit_record;
  if (TraceRay(origin, wi)) {
    // return vec3(0.0, 0.0, 1.0);
    // return 20.0 * vec3(angle);
    // float cos_i = max(dot(origin_normal, direction), 0.0f);
    // float cos_o = max(dot(normal, -direction), 0.0f);
    // float f0 = cos_i * cos_o / (ray_length * ray_length);
    // float cos_i_o = max(dot(origin_normal, normal), 0.0);
    if (hit_record.hit_entity_id == emission_entity_id && 
        ray_payload.primitive_id == face_id) {
      energy = materials[emission_entity_id].emission * 
               materials[emission_entity_id].emission_strength *  
               max(dot(origin_normal, wi), 0.0) * angle *
               object_info.num_faces * guo.num_emissions;
    }
    // energy = f0 * area * materials[emission_entity_id].emission * materials[emission_entity_id].emission_strength * angle;
    // return vec3(0.0, 0.0, 1.0);
    // return cos_i * cos_o * materials[emission_entity_id].emission * materials[emission_entity_id].emission_strength;
  }
  hit_record = save_hit_record;
  // energy = clamp(energy, 0.0, 1.0);
  // }}
  return energy;
}

vec3 SampleEmission2(vec3 origin, vec3 origin_normal) {
  vec3 energy = vec3(0.0);
  uint emission_id = RandomInt(guo.num_emissions);
  // for (uint emission_id = 0; emission_id < guo.num_emissions; emission_id++) {
  uint emission_entity_id = emissions[emission_id];
  ObjectInfo object_info = object_infos[emission_entity_id];
  uint face_id = RandomInt(object_info.num_faces);
  // for (uint face_id = 0; face_id < object_info.num_faces; face_id++) {
  Vertex v0 = GetVertex(
      object_info.vertex_offset +
      indices[object_info.index_offset + face_id * 3 + 0]);
  Vertex v1 = GetVertex(
      object_info.vertex_offset +
      indices[object_info.index_offset + face_id * 3 + 1]);
  Vertex v2 = GetVertex(
      object_info.vertex_offset +
      indices[object_info.index_offset + face_id * 3 + 2]);
  vec3 barycentric;
  barycentric.x = RandomFloat();
  barycentric.y = RandomFloat() * (1.0 - barycentric.x);
  barycentric.z = 1 - barycentric.x - barycentric.y;
  mat3 object_to_world = mat3(entity_objects[emission_entity_id].model);
  mat3 positions = mat3(entity_objects[emission_entity_id].model * 
                        mat3x4(vec4(v0.position, 1.0), vec4(v1.position, 1.0), 
                               vec4(v2.position, 1.0)));

  // if (length(positions[0] - vec3(0.343, 0.548, 0.227)) < 1e-3) {
  //   return vec3(0.0, 1.0, 1.0);
  // }
  // else {
  //   return vec3(1.0, 0.0, 1.0);
  // }
  // float angle;
  // vec3 wi;
  // bool result = 
  // SampleSolidAngle(origin, positions, angle, wi);
  // if (result) {
  //   return vec3(1.0);
  // }
  // else {
  //   return vec3(0.0);
  // }
  vec3 position = positions * barycentric;
  float ray_length = length(position - origin);
  vec3 direction = normalize(position - origin);
  vec3 normal = normalize(transpose(inverse(object_to_world)) *
                          mat3(v0.normal, v1.normal, v2.normal) *
                          barycentric);
  vec3 sign_area = cross(positions[1] - positions[0], positions[2] - positions[1]);
  float area = length(sign_area) / 2.0 ;
  vec3 geometry_normal = normalize(sign_area);
  if (dot(normal, geometry_normal) < 0.0) {
    geometry_normal = -geometry_normal;
  }
  if (dot(direction, geometry_normal) > 0.0) {
    geometry_normal = -geometry_normal;
    normal = -normal;
  }
  // if (dot(-direction, normal) > 0) {
  //   return vec3(0.0, 0.0, 1.0);
  // }
  // else {
  //   return vec3(0.0);
  // }
  // if (angle < 0) {
  //   return vec3(1.0,1.0,1.0);
  // }
  // else {
  //   return vec3(0.0);
  // }

  // if (!TraceRay(origin, direction, ray_length - 1e-3)) {
  HitRecord save_hit_record = hit_record;
  if (TraceRay(origin, direction)) {
    // return vec3(0.0, 0.0, 1.0);
    // return 20.0 * vec3(angle);
    // float cos_i = max(dot(origin_normal, direction), 0.0f);
    // float cos_o = max(dot(normal, -direction), 0.0f);
    // float f0 = cos_i * cos_o / (ray_length * ray_length);
    // float cos_i_o = max(dot(origin_normal, normal), 0.0);
    if (hit_record.hit_entity_id == emission_entity_id && 
        ray_payload.primitive_id == face_id) {
      energy = materials[emission_entity_id].emission * materials[emission_entity_id].emission_strength *  
               max(dot(origin_normal, direction), 0.0) * area *
               max(dot(normal, -direction), 0.0) *
               object_info.num_faces * guo.num_emissions /
               (ray_length * ray_length);
    }
    // energy = f0 * area * materials[emission_entity_id].emission * materials[emission_entity_id].emission_strength * angle;
    // return vec3(0.0, 0.0, 1.0);
    // return cos_i * cos_o * materials[emission_entity_id].emission * materials[emission_entity_id].emission_strength;
  }
  hit_record = save_hit_record;
  // energy = clamp(energy, 0.0, 1.0);
  // }}
  return energy;
}

float pow5(float x) {
  float pow2 = x * x;
  return pow2 * pow2 * x;
}

float FrDielectric(float cosThetaI, float etaI, float etaT, bool entering) {
  if (!entering) {
      float tmp = etaI;
      etaI = etaT;
      etaT = tmp;
  }

  // Compute _cosThetaT_ using Snell's law
  float sinThetaI = sqrt(max(0.0, 1.0 - cosThetaI * cosThetaI));
  float sinThetaT = etaI / etaT * sinThetaI;

  // Handle total internal reflection
  if (sinThetaT >= 1) return 1;
  float cosThetaT = sqrt(max(0.0, 1.0 - sinThetaT * sinThetaT));
  float Rparl = ((etaT * cosThetaI) - (etaI * cosThetaT)) /
                ((etaT * cosThetaI) + (etaI * cosThetaT));
  float Rperp = ((etaI * cosThetaI) - (etaT * cosThetaT)) /
                ((etaI * cosThetaI) + (etaT * cosThetaT));
  return (Rparl * Rparl + Rperp * Rperp) / 2;
}

float sqr(float x) {
  return x * x;
}

float SchlickR0FromEta(float eta) {
  return sqr(eta - 1.0) / sqr(eta + 1.0);
}

bool Refract(vec3 wi, vec3 n, float eta, out vec3 wt) {
    // Compute $\cos \theta_\roman{t}$ using Snell's law
    float cosThetaI = dot(n, wi);
    float sin2ThetaI = max(0.0, 1.0 - cosThetaI * cosThetaI);
    float sin2ThetaT = eta * eta * sin2ThetaI;

    // Handle total internal reflection for transmission
    if (sin2ThetaT >= 1.0) return false;
    float cosThetaT = sqrt(1.0 - sin2ThetaT);
    wt = normalize(eta * -wi + (eta * cosThetaI - cosThetaT) * n);
    return true;
}

vec3 SampleRay1(vec3 origin, vec3 direction) {
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);
  vec3 p = origin;
  vec3 n = direction;
  vec3 wo = direction;
  vec3 wi = direction;
  vec3 Fr;
  Material material;
  if (!TraceRay(p, wi)) {
    radiance += throughput * SampleEnvmap(wi);
    return radiance;
  }
  else {
    material = materials[hit_record.hit_entity_id];
    if (material.material_type == MATERIAL_TYPE_EMISSION) {
      radiance += throughput * material.emission * material.emission_strength;
      return radiance;
    }
  }
  // radiance += INV_PI * SampleLight(p, n);
  // float prob = pow(1e-6, 1.0 / guo.num_bounces);
  float prob = 0.8;
  int cnt = 0;
  bool pass_diffuse = false;
  for (float b = RandomFloat(); b < prob && cnt < guo.num_bounces; b = RandomFloat()) {
  // float prob = guo.num_bounces / (guo.num_bounces + 1.0);
  // int cnt = 0;
  // for (float b = 0.0; b < prob && cnt < 4 * guo.num_bounces; b = RandomFloat()) {
    // if (material.material_type == MATERIAL_TYPE_EMISSION) {
    //   radiance += throughput * material.emission * material.emission_strength;
    //   break;
    // }
    // vec3 Li = material.diffuse * 0.5 * INV_PI / dot(n, wi) / dot(r, r);
    p = hit_record.position;
    n = hit_record.normal;
    vec3 t = hit_record.tangent;

    // wo = -wi;
    // wi = BRDFImportanceSampling(n, t, material);

    if (material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
      wo = -wi;
      wi = ImportanceSamplingLamberrian(n, t);
      Fr = material.diffuse *
              vec3(texture(texture_samplers[material.diffuse_texture_id],
                    hit_record.tex_coord));
      throughput *= Fr / prob;

      radiance += throughput * SampleEmission(p, n) * INV_PI;

      pass_diffuse = true;
    }
    else if (material.material_type == MATERIAL_TYPE_SPECULAR) {
      wo = -wi;
      float alpha = material.roughness * material.roughness;
      vec3 wh = ImportanceSamplingSpecular(n, t, alpha);
      wi = 2.0 * wh * dot(wh, wo) - wo; 
      // return vec3(max(0.0,dot(n,wi)));
      vec3 F0 = material.specular * 
           vec3(texture(texture_samplers[material.specular_texture_id],
                hit_record.tex_coord));
      // Fr = F0 * dot(wo, wh) / dot(n, wo);
      float oh = max(dot(wo, wh),0.0);
      vec3 F = F0 + (1.0 - F0) * pow5(1.0 - oh);
      // Fr = F * max(dot(wo, wh),0.0);
      // float k = alpha + 1.0;
      // k = k * k / 8.0;
      float no = max(dot(n, wo), 0.0);
      float ni = max(dot(n, wi), 0.0);
      float nh = max(dot(n, wh), 0.0);
      float Vis_SmithVL = no * (ni * (1.0 - alpha) + alpha) + 
                          ni * (no * (1.0 - alpha) + alpha);
      if (Vis_SmithVL <= 0.0 || nh == 0.0) {
        Fr = vec3(0.0);
      }
      else {
        Fr = F * 2.0 * oh * ni / nh / Vis_SmithVL;
      }
      // return vec3(dot(n, wh));
      // float G1 = no / (no * (1.0 - k) + k);
      // float G2 = ni / (ni * (1.0 - k) + k);
      // float G = G1 * G2;
      // Fr = F * G * dot(wo, wh) / no;
      throughput *= Fr / prob;
      // throughput *= F0 / prob;
    }
    else if (material.material_type == MATERIAL_TYPE_TRANSMISSIVE) {
      wo = -wi;
      float alpha = material.roughness * material.roughness;
      vec3 wh = ImportanceSamplingSpecular(n, t, alpha);
      float oh = max(dot(wo, wh), 0.0);
      float F = FrDielectric(oh, 1.0, material.ior, hit_record.front_face);
      // return vec3(F);
      vec3 T = sqrt(material.transmittance);
      Fr = vec3(0.0);
      if (RandomFloat() < F) {
      // if (RandomFloat() < 0) {
        // return vec3(0.0) / prob;
        // continue;
        wi = 2.0 * wh * dot(wh, wo) - wo; 
        float no = max(dot(n, wo), 0.0);
        float ni = max(dot(n, wi), 0.0);
        float nh = max(dot(n, wh), 0.0);
        float Vis_SmithVL = no * (ni * (1.0 - alpha) + alpha) + 
                            ni * (no * (1.0 - alpha) + alpha);
        if (Vis_SmithVL > 0.0 && nh > 0.0) {
          Fr = T * 2.0 * oh * ni / nh / Vis_SmithVL;
        }
      }
      else {
        // throughput *= vec3(1,0,0);
        float eta = hit_record.front_face ? (1.0 / material.ior) : (material.ior / 1.0);
        if (Refract(wo, wh, eta, wi)) {
          float ih = max(dot(wi, -wh), 0.0);
          float sqrtDenom = oh + eta * ih;
          // return vec3(sqrtDenom) / prob;

          float no = max(dot(n, wo), 0.0);
          float ni = max(dot(-n, wi), 0.0);
          float nh = max(dot(n, wh), 0.0);
          float Vis_SmithVL = no * (ni * (1.0 - alpha) + alpha) + 
                              ni * (no * (1.0 - alpha) + alpha);
          if (Vis_SmithVL > 0.0 && nh > 0.0 && sqrtDenom > 0.0) {
            Fr = T * 8.0 * oh * ni * ih * oh / nh / Vis_SmithVL / (sqrtDenom * sqrtDenom);
          }
        }
      }
      throughput *= Fr / prob;
    }
    else {
      break;
    }


    // throughput *= Fr / prob;

    // radiance += throughput * INV_PI * SampleEmission(p, n);
    // radiance += throughput * SampleEmission(p, n);

    if (!TraceRay(p, wi)) {
      if (material.material_type == MATERIAL_TYPE_SPECULAR) {
        if (pass_diffuse) {
          radiance += throughput * SampleEnvmap(wi);
        } else {
          radiance += throughput * SampleEnvmap(wi);
        } 
      }
      else {
        // vec3 env_ambient = guo.envmap_minor_color + guo.envmap_major_color * 2.0 *
        //             max(0.0, dot(guo.envmap_light_direction, hit_record.normal));
        // radiance += throughput * env_ambient;
        p = hit_record.position;
        wi = guo.envmap_light_direction;
        n = hit_record.normal;
        radiance += throughput * guo.envmap_minor_color;
        if (!TraceRay(p, wi)) {
          radiance += throughput * max(dot(wi, n), 0.0) * 2.0 * guo.envmap_major_color;
        }
      }
      break;
    }
    if (material.material_type == MATERIAL_TYPE_SPECULAR) {
      radiance += throughput * materials[hit_record.hit_entity_id].emission;
    }
    material = materials[hit_record.hit_entity_id];
    // radiance += throughput * material.emission * material.emission_strength;

    // if ((material.material_type & MATERIAL_TYPE_EMISSION) > 0) {
    //   break;
    // }

    // radiance += throughput * guo.envmap_minor_color;
    // throughput *= max(dot(direction, hit_record.normal), 0.0) * 2.0;
    // if (!TraceRay(origin, direction)) {
    //   radiance += throughput * guo.envmap_major_color;
    // }
    // break;
    cnt++;
  }
  return radiance;
}

void main() {
  // const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  // const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  // vec2 d = inUV * 2.0 - 1.0;

  mat4 camera_to_world = inverse(guo.camera);
  mat4 screen_to_camera = inverse(guo.projection);

  for (int i = 0; i < guo.num_samples; i++) {
    // InitRandomSeed(uint(pixelCenter.x), uint(pixelCenter.y),
    //                guo.accumulated_sample + i);
    InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y,
                   guo.accumulated_sample + i);
    vec2 pixelPoint = vec2(gl_LaunchIDEXT.xy) + vec2(RandomFloat(), RandomFloat());
    vec2 inUV = pixelPoint / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;
    // const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    // const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    // vec2 d = inUV * 2.0 - 1.0;
    vec4 origin = camera_to_world * vec4(0, 0, 0, 1);
    vec4 target = screen_to_camera * vec4(d.x, d.y, 1, 1);
    vec4 direction = camera_to_world * vec4(normalize(target.xyz), 0);

    imageStore(accumulation_color, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_color, ivec2(gl_LaunchIDEXT.xy)) +
                   vec4(SampleRay1(origin.xyz, direction.xyz), 1.0));
    imageStore(accumulation_number, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_number, ivec2(gl_LaunchIDEXT.xy)) + 1.0);
  }
}
